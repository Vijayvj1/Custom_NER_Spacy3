import numpy as np
from scipy.optimize import minimize

def distance(x, y, z, x0, y0, z0):
    return np.sqrt((x - x0)**2 + (y - y0)**2 + (z - z0)**2)

def objective_function(point, distances, reference_points):
    errors = [distance(point[0], point[1], point[2], *ref_point) - dist for dist, ref_point in zip(distances, reference_points)]
    return np.sum(np.square(errors))

def multilateration_least_squares(distances, reference_points, max_distance_threshold=100.0):
    # Check if any distance is greater than the threshold
    if any(dist > max_distance_threshold for dist in distances):
        raise ValueError("Distances exceed the maximum threshold. Multilateration not possible.")

    # Initial guess for the unknown point (x, y, z)
    initial_guess = np.mean(reference_points, axis=0)

    result = minimize(objective_function, initial_guess, args=(distances, reference_points), method='BFGS')
    return result.x

# Example usage:
if __name__ == "__main__":
    # Given distances and reference points in 3D
    distances = [3,3,3,3,2]
    reference_points = [(1.75768,4.3556,2.51146), (5.69595,6.49432,2), (2.74,2.17,4.32),(7.15,5.05,4.19),(4.1,4.22,0.64)]
    max_distance_threshold = 20.0

    try:
        # Calculate the 3D multilateration result
        result = multilateration_least_squares(distances, reference_points, max_distance_threshold)
        x, y, z = result
        print("Multilateration result: x =", x, ", y =", y, ", z =", z)

    except ValueError as e:
        print("Error:", str(e))
