import numpy as np
from scipy.optimize import minimize

def distance(x, y, x0, y0):
    return np.sqrt((x - x0)**2 + (y - y0)**2)

def objective_function(point, distances, reference_points):
    errors = [distance(point[0], point[1], *ref_point) - dist for dist, ref_point in zip(distances, reference_points)]
    return np.sum(np.square(errors))

def trilateration_least_squares(distances, reference_points, max_distance_threshold=100.0):
    print(distances)
    # Check if any distance is greater than the threshold
    if any(dist > max_distance_threshold for dist in distances):
        raise ValueError("Distances exceed the maximum threshold. Trilateration not possible.")

    # Initial guess for the unknown point (x, y)
    initial_guess = np.mean(reference_points, axis=0)

    result = minimize(objective_function, initial_guess, args=(distances, reference_points), method='BFGS')
    return result.x

# Example usage:
if __name__ == "__main__":
    # Given distances and reference points
    distances = [4.564383857652639, 2.2, 2.83]
    reference_points = [(5.62,9.11), (8,9), (13,9)]
    max_distance_threshold = 20

    try:
        # Calculate the trilateration result
        result = trilateration_least_squares(distances, reference_points, max_distance_threshold)
        x, y = result
        print("Trilateration result: x =", x, ", y =", y)
        print(x,y)

    except ValueError as e:
        print("Error:", str(e))
